#!/usr/bin/env python3.4
#
# This file is part of environmentd.
#
# environmentd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# environmentd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with environmentd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon process for monitoring the low-level hardware daemons.  Hardware
   status and weather conditions are aggregated over a time period, and can
   be queried to determine whether it is safe to observe."""

# pylint: disable=too-many-locals
# pylint: disable=broad-except
# pylint: disable=too-few-public-methods
# pylint: disable=too-many-arguments
# pylint: disable=too-many-return-statements
# pylint: disable=too-many-instance-attributes

import datetime
import sys
import Pyro4
from warwick.observatory.common import (
    daemons,
    log,
    IP)
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.w1m.environment import (
    PyroWatcher,
    AggregateParameter,
    AggregateBehaviour,
    ParameterStatus,
    CommandStatus)

# Include more detailed exceptions
sys.excepthook = Pyro4.util.excepthook

# Machines that are allowed to issue parameter overrides and clear history
CONTROL_IPS = [IP.OneMetreDome, IP.OneMetreTCS]

# Delay (in seconds) that we must wait after weather conditions return to
# nominal values before we consider it safe to open the dome.  This also applies
# to the initial startup, while we wait to build sufficient history.
CONDITION_WINDOW_LENGTH = datetime.timedelta(minutes=20)
DISKSPACE_WINDOW_LENGTH = datetime.timedelta(minutes=2)

# Maximum gap that we will accept between measurements (due to query failures,
# etc). If this is exceeded, then we will force the dome to close until the
# condition timeout passes.
TIME_GAP_MAX = datetime.timedelta(seconds=30)
TNG_TIME_GAP_MAX = datetime.timedelta(minutes=10)
DISKSPACE_TIME_GAP_MAX = datetime.timedelta(minutes=1)
NETPING_TIME_GAP_MAX = datetime.timedelta(minutes=5)

# Delay (in seconds) between update iterations.
# Actual query period will be slightly longer than this due to comms delays.
VAISALA_QUERY_DELAY = 10
ROOMALERT_QUERY_DELAY = 10
SUPERWASP_QUERY_DELAY = 10
TNG_QUERY_DELAY = 300
POWER_QUERY_DELAY = 10
DISKSPACE_QUERY_DELAY = 30
NETPING_QUERY_DELAY = 30

# Safe operating ranges. Dome will be closed if these parameters aren't met
VAISALA_PARAMETERS = [
    AggregateParameter('wind_speed', AggregateBehaviour.RangeWithLimits, limits=(0, 40)),
    AggregateParameter('wind_speed_valid', AggregateBehaviour.Set, valid_set_values=set([True])),
    AggregateParameter('median_wind_speed', AggregateBehaviour.MedianWithLimits,
                       measurement_name='wind_speed', limits=(0, 25)),
    AggregateParameter('temperature', AggregateBehaviour.RangeWithLimits, limits=(0, 50)),
    AggregateParameter('temperature_valid', AggregateBehaviour.Set, valid_set_values=set([True])),
    AggregateParameter('relative_humidity', AggregateBehaviour.RangeWithLimits, limits=(0, 75)),
    AggregateParameter('relative_humidity_valid', AggregateBehaviour.Set,
                       valid_set_values=set([True])),
    AggregateParameter('pressure', AggregateBehaviour.RangeWithLimits, limits=(600, 1100)),
    AggregateParameter('pressure_valid', AggregateBehaviour.Set, valid_set_values=set([True])),
    AggregateParameter('accumulated_rain', AggregateBehaviour.RangeWithLimits, limits=(0, 0)),
    AggregateParameter('accumulated_rain_valid', AggregateBehaviour.Set,
                       valid_set_values=set([True])),
    AggregateParameter('dew_point_delta', AggregateBehaviour.RangeWithLimits, limits=(2, 100)),
    AggregateParameter('dew_point_delta_valid', AggregateBehaviour.Set,
                       valid_set_values=set([True])),
]

ROOMALERT_PARAMETERS = [
    AggregateParameter('internal_temp', AggregateBehaviour.RangeWithLimits, limits=(0, 50)),
    AggregateParameter('internal_humidity', AggregateBehaviour.RangeWithLimits, limits=(0, 75)),

    AggregateParameter('roomalert_temp', AggregateBehaviour.Range),
    AggregateParameter('roomalert_humidity', AggregateBehaviour.Range),
    AggregateParameter('truss_temp', AggregateBehaviour.Range),
    AggregateParameter('hatch_closed', AggregateBehaviour.Set),
    AggregateParameter('trap_closed', AggregateBehaviour.Set),
    AggregateParameter('security_system_safe', AggregateBehaviour.Set,
                       valid_set_values=set([True])),
]

SUPERWASP_PARAMETERS = [
    AggregateParameter('sky_temp', AggregateBehaviour.Range),
    AggregateParameter('ext_humidity', AggregateBehaviour.Range, limits=(0, 75)),
    AggregateParameter('dew_point_delta', AggregateBehaviour.Range, limits=(2, 100)),
]

TNG_PARAMETERS = [
    AggregateParameter('dust', AggregateBehaviour.Latest),
    AggregateParameter('dust_valid', AggregateBehaviour.Latest),
    AggregateParameter('solarimeter', AggregateBehaviour.Latest),
    AggregateParameter('solarimeter_valid', AggregateBehaviour.Latest),
    AggregateParameter('seeing', AggregateBehaviour.Latest),
    AggregateParameter('seeing_valid', AggregateBehaviour.Latest)
]

DISKSPACE_PARAMETERS = [
    AggregateParameter('data_fs_available_bytes', AggregateBehaviour.LatestWithLimits,
                       limits=(5 * 2**30, 2**40)),
    AggregateParameter('data_fs_percent_available', AggregateBehaviour.LatestWithLimits,
                       limits=(5, 100)),
]

NETPING_PARAMETERS = [
    AggregateParameter('google', AggregateBehaviour.RangeWithLimits, limits=(0, 2000)),
    AggregateParameter('ngtshead', AggregateBehaviour.RangeWithLimits, limits=(0, 2000)),
]

POWER_PARAMETERS = [
    AggregateParameter('main_ups_status', AggregateBehaviour.Set, valid_set_values=set([2])),
    AggregateParameter('main_ups_battery_healthy', AggregateBehaviour.Set),
    AggregateParameter('main_ups_battery_remaining', AggregateBehaviour.RangeWithLimits,
                       limits=(85, 101)),
    AggregateParameter('dome_ups_status', AggregateBehaviour.Set, valid_set_values=set([2])),
    AggregateParameter('dome_ups_battery_healthy', AggregateBehaviour.Set),
    AggregateParameter('dome_ups_battery_remaining', AggregateBehaviour.RangeWithLimits,
                       limits=(85, 101)),
    AggregateParameter('light', AggregateBehaviour.Set),
]

class EnvironmentDaemon:
    """Daemon class for communicating with the lower level hardware daemons"""

    def __init__(self):
        self._watchers = [
            PyroWatcher('vaisala', daemons.onemetre_vaisala, VAISALA_QUERY_DELAY,
                        TIME_GAP_MAX, CONDITION_WINDOW_LENGTH, VAISALA_PARAMETERS),
            PyroWatcher('roomalert', daemons.onemetre_roomalert, ROOMALERT_QUERY_DELAY,
                        TIME_GAP_MAX, CONDITION_WINDOW_LENGTH, ROOMALERT_PARAMETERS),
            PyroWatcher('superwasp', daemons.superwasp_log, SUPERWASP_QUERY_DELAY,
                        TIME_GAP_MAX, CONDITION_WINDOW_LENGTH, SUPERWASP_PARAMETERS),
            PyroWatcher('tng', daemons.tng_log, TNG_QUERY_DELAY, TNG_TIME_GAP_MAX,
                        CONDITION_WINDOW_LENGTH, TNG_PARAMETERS),
            PyroWatcher('diskspace', daemons.onemetre_tcs_diskspace,
                        DISKSPACE_QUERY_DELAY, DISKSPACE_TIME_GAP_MAX,
                        DISKSPACE_WINDOW_LENGTH, DISKSPACE_PARAMETERS),
            PyroWatcher('netping', daemons.observatory_network_ping,
                        NETPING_QUERY_DELAY, NETPING_TIME_GAP_MAX, CONDITION_WINDOW_LENGTH,
                        NETPING_PARAMETERS),
            PyroWatcher('power', daemons.onemetre_power, POWER_QUERY_DELAY,
                        TIME_GAP_MAX, CONDITION_WINDOW_LENGTH, POWER_PARAMETERS)
        ]

    @Pyro4.expose
    def status(self):
        """Returns the aggregated dashboard status of the monitored daemons."""
        ret = {}
        for watcher in self._watchers:
            ret[watcher.daemon_name] = watcher.status()
        return ret

    @Pyro4.expose
    def safe_to_observe(self):
        """Returns true if conditions are safe to observe."""
        return not any(w.status()['status'] == ParameterStatus.Unsafe for w in self._watchers)

    @Pyro4.expose
    def clear_history(self):
        """Clear the cached measurements"""
        if not pyro_client_matches(CONTROL_IPS):
            return CommandStatus.InvalidControlIP

        print('{} MESSAGE: clearing cached history' \
            .format(datetime.datetime.utcnow()))
        log.warning('environmentd', 'Clearing cached environment measurements')
        for watcher in self._watchers:
            watcher.clear_history()
        return CommandStatus.Success

if __name__ == '__main__':
    daemons.onemetre_environment.launch(EnvironmentDaemon())
