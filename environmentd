#!/usr/bin/env python3
#
# This file is part of environmentd.
#
# environmentd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# environmentd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with environmentd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon process for monitoring the low-level hardware daemons.  Hardware
   status and weather conditions are aggregated over a time period, and can
   be queried to determine whether it is safe to observe."""

# pylint: disable=too-many-locals
# pylint: disable=broad-except
# pylint: disable=too-few-public-methods

from collections import deque
import datetime
import math
import threading
import time
import Pyro4

# Settings for this daemon
PYRO_HOST = '192.168.0.102'
PYRO_PORT = 9002
PYRO_NAME = 'environment_daemon'
PYRO_COMM_TIMEOUT = 5

# Settings for low-level daemons
VAISALA_HOST = '192.168.0.102'
VAISALA_PORT = 9001
VAISALA_NAME = 'vaisala_daemon'

ROOMALERT_HOST = '192.168.0.102'
ROOMALERT_PORT = 9008
ROOMALERT_NAME = 'roomalert_daemon'

SUPERWASP_HOST = '192.168.0.102'
SUPERWASP_PORT = 9007
SUPERWASP_NAME = 'superwasp_daemon'

# TODO: Include UPS status
# TODO: Include disk space

VAISALA_URI = 'PYRO:' + VAISALA_NAME + '@' + VAISALA_HOST + ':' + str(VAISALA_PORT)
ROOMALERT_URI = 'PYRO:' + ROOMALERT_NAME + '@' + ROOMALERT_HOST + ':' + str(ROOMALERT_PORT)
SUPERWASP_URI = 'PYRO:' + SUPERWASP_NAME + '@' + SUPERWASP_HOST + ':' + str(SUPERWASP_PORT)

# Delay (in seconds) that we must wait after weather conditions return to
# nominal values before we consider it safe to open the dome.  This also applies
# to the initial startup, while we wait to build sufficient history.
CONDITION_TIMEOUT_DELAY = datetime.timedelta(minutes=20)

# Maximum gap that we will accept between measurements (due to query failures,
# etc). If this is exceeded, then we will force the dome to close until the
# condition timeout passes.
TIME_GAP_MAX = datetime.timedelta(seconds=30)

# Delay (in seconds) between update iterations.
# Actual query period will be slightly longer than this due to comms delays.
VAISALA_QUERY_DELAY = 10
ROOMALERT_QUERY_DELAY = 10
SUPERWASP_QUERY_DELAY = 10

class AggregateBehaviour:
    """Aggregation behaviour"""
    RangeWithLimits, Range, Set, Latest = range(4)

class AggregateParameter:
    """Defines the aggregation behaviour for a specific environment parameter"""
    def __init__(self, name, behaviour, limits=None):
        self.name = name
        self._behaviour = behaviour
        self._limits = limits

    def aggregate(self, data, max_first_date):
        """Aggregate measurement data"""
        if self._behaviour == AggregateBehaviour.RangeWithLimits or \
                self._behaviour == AggregateBehaviour.Range:

            values = []
            for measurement in data:
                if measurement['date'] > max_first_date:
                    values.append(measurement[self.name])

            if len(values) == 0:
                return (0, 0, False)

            low = values[0]
            high = values[0]
            for value in values:
                low = min(value, low)
                high = max(value, high)

            valid = self._behaviour == AggregateBehaviour.Range or \
                (low > self._limits[0] and high < self._limits[1])

            return (low, high, valid)
        elif self._behaviour == AggregateBehaviour.Set:
            ret = set()
            for measurement in data:
                if measurement['date'] > max_first_date:
                    ret.add(measurement[self.name])

            # set can't be serialized to JSON, so convert to list now
            return list(ret)
        else:
            latest_value = 0
            latest_date = max_first_date
            for measurement in data:
                date = measurement['date']
                if date > latest_date:
                    latest_date = date
                    latest_value = measurement[self.name]
        return (latest_value, latest_date > max_first_date)

# Safe operating ranges. Dome will be closed if these parameters aren't met

VAISALA_PARAMETERS = [
    AggregateParameter('wind_speed', AggregateBehaviour.RangeWithLimits, limits=(0, 30)),
    AggregateParameter('temperature', AggregateBehaviour.RangeWithLimits, limits=(0, 50)),
    AggregateParameter('relative_humidity', AggregateBehaviour.RangeWithLimits, limits=(0, 75)),
    AggregateParameter('pressure', AggregateBehaviour.RangeWithLimits, limits=(600, 1100)),
]

ROOMALERT_PARAMETERS = [
    AggregateParameter('external_temp', AggregateBehaviour.RangeWithLimits, limits=(0, 50)),
    AggregateParameter('external_humidity', AggregateBehaviour.RangeWithLimits, limits=(0, 75)),
    AggregateParameter('internal_temp', AggregateBehaviour.RangeWithLimits, limits=(0, 50)),
    AggregateParameter('internal_humidity', AggregateBehaviour.RangeWithLimits, limits=(0, 75)),

    AggregateParameter('roomalert_temp', AggregateBehaviour.Range),
    AggregateParameter('roomalert_humidity', AggregateBehaviour.Range),
    AggregateParameter('truss_temp', AggregateBehaviour.Range),
    AggregateParameter('hatch_closed', AggregateBehaviour.Set),
    AggregateParameter('trap_closed', AggregateBehaviour.Set),
]

SUPERWASP_PARAMETERS = [
    AggregateParameter('sky_temp', AggregateBehaviour.RangeWithLimits, limits=(-100, -30)),
    AggregateParameter('ext_humidity', AggregateBehaviour.RangeWithLimits, limits=(0, 75)),
    AggregateParameter('dew_point_delta', AggregateBehaviour.RangeWithLimits, limits=(2, 100)),
]

class PyroWatcher:
    """Watches the state of a Pyro daemon implementing the last_measurement convention"""
    def __init__(self, daemon_name, pyro_uri, query_delay, parameters):
        self._daemon_name = daemon_name
        self._pyro_uri = pyro_uri
        self._query_delay = query_delay
        self._parameters = parameters

        # Place a hard limit on the number of stored measurements to simplify
        # cleanup.  Additional filtering is required when iterating the queue.
        queue_len = CONDITION_TIMEOUT_DELAY.seconds * \
            1.1 / query_delay
        self._data = deque(maxlen=math.ceil(queue_len))

        runloop = threading.Thread(target=self.__run_thread)
        runloop.daemon = True
        runloop.start()

    def __run_thread(self):
        """Run loop for monitoring the hardware daemon"""
        while True:
            now = datetime.datetime.utcnow
            try:
                # The delay between queries is greater than the comm timeout
                # so there is no point caching the proxy between loops
                daemon = Pyro4.Proxy(self._pyro_uri)
                data = daemon.last_measurement()

                if data is not None:
                    # Pryo doesn't deserialize dates, so we manually manage this.
                    data['date'] = datetime.datetime.strptime(data['date'], '%Y-%m-%dT%H:%M:%SZ')
                    if now() - data['date'] > TIME_GAP_MAX:
                        print('{} WARNING: recieved stale data from {}: {}' \
                        .format(now(), self._daemon_name, data['date']))

                    self._data.append(data)
                else:
                    print('{} WARNING: recieved empty data from {}' \
                        .format(now(), self._daemon_name))
            except Exception as exception:
                print('{} ERROR: failed to query from {}: {}' \
                      .format(now(), self._daemon_name, str(exception)))

            time.sleep(self._query_delay)

    def status(self, max_first_date, min_last_date):
        """Queries the aggregate status of the vaisala weather station.
           Returns a tuple of observability and data"""

        measurement_start = None
        measurement_end = None
        queue_start = None
        queue_len = 0
        sufficient_data = True

        # check if we have sufficient data
        for measurement in self._data:
            queue_len += 1
            date = measurement['date']

            # This is the first measurement with a valid date
            if queue_start is None:
                queue_start = date

            if measurement_end is None:
                measurement_end = date

            # Only include measurements within the desired window
            if date > max_first_date:
                if measurement_start is None:
                    measurement_start = date

                if date - measurement_end > TIME_GAP_MAX:
                    sufficient_data = False

            measurement_end = date

        # Check that the first measurement was sufficiently old
        if queue_start is None or queue_start > max_first_date:
            sufficient_data = False

        # Check the time between the last measurement and now
        if measurement_end is None or measurement_end < min_last_date:
            sufficient_data = False

        data = {
            self._daemon_name+'_sufficient_data': sufficient_data,
            self._daemon_name+'_queue_len': queue_len
        }

        # Can observe only if we have sufficient data and all of the parameters
        # are within their defined safe limits
        can_observe = sufficient_data
        if queue_len > 0:
            for param in self._parameters:
                key = self._daemon_name+'_'+param.name
                value = param.aggregate(self._data, max_first_date)
                data.update({key: value})
                can_observe = can_observe and value[2]

            data.update({
                self._daemon_name+'_measurement_start':
                    measurement_start.strftime('%Y-%m-%dT%H:%M:%SZ'),
                self._daemon_name+'_measurement_end':
                    measurement_end.strftime('%Y-%m-%dT%H:%M:%SZ'),
                self._daemon_name+'_queue_start':
                    queue_start.strftime('%Y-%m-%dT%H:%M:%SZ')
            })

        return (can_observe, data)

    def clear_history(self):
        """Clear the cached measurements"""
        self._data.clear()

class EnvironmentDaemon:
    """Daemon class for communicating with the lower level hardware daemons"""

    def __init__(self):
        self._watchers = [
            PyroWatcher('vaisala', VAISALA_URI, VAISALA_QUERY_DELAY, VAISALA_PARAMETERS),
            PyroWatcher('roomalert', ROOMALERT_URI, ROOMALERT_QUERY_DELAY, ROOMALERT_PARAMETERS),
            PyroWatcher('superwasp', SUPERWASP_URI, SUPERWASP_QUERY_DELAY, SUPERWASP_PARAMETERS)
        ]

    def status(self):
        """Returns the aggregated status of the monitored daemons.
           Each measurement is a tuple of min value, max value, measurement valid
        """
        # The youngest date that the first measurement can take while remaining valid
        max_first_date = datetime.datetime.utcnow() - CONDITION_TIMEOUT_DELAY

        # The oldest date that the last measurement can take while remaining valid
        min_last_date = datetime.datetime.utcnow() - TIME_GAP_MAX

        can_observe = True
        ret = {}
        for watcher in self._watchers:
            obs, data = watcher.status(max_first_date, min_last_date)
            can_observe = can_observe and obs
            ret.update(data)

        ret.update({'can_observe': can_observe})
        return ret

    def clear_history(self):
        """Clear the cached measurements"""
        print('{} MESSAGE: clearing cached history' \
            .format(datetime.datetime.utcnow()))
        for watcher in self._watchers:
            watcher.clear_history()

def spawn_daemon():
    """Spawns the daemon and registers it with Pyro"""
    Pyro4.config.COMMTIMEOUT = PYRO_COMM_TIMEOUT
    Pyro4.config.DETAILED_TRACEBACK = True
    pyro = Pyro4.Daemon(host=PYRO_HOST, port=PYRO_PORT)

    environment = EnvironmentDaemon()
    uri = pyro.register(environment, objectId=PYRO_NAME)

    print('{} MESSAGE: Starting environment daemon with Pyro ID: {}' \
        .format(datetime.datetime.utcnow(), uri))
    pyro.requestLoop()
    print('{} MESSAGE: Stopping environment daemon with Pyro ID: {}' \
        .format(datetime.datetime.utcnow(), uri))

if __name__ == '__main__':
    spawn_daemon()
