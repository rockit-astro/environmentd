#!/usr/bin/env python3.4
#
# This file is part of environmentd.
#
# environmentd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# environmentd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with environmentd.  If not, see <http://www.gnu.org/licenses/>.

"""Commandline client for communicating with environmentd"""

# pylint: disable=too-many-statements
# pylint: disable=too-many-branches
# pylint: disable=too-many-locals
# pylint: disable=too-few-public-methods

import datetime
import json
import os
import sys
import Pyro4
from warwick.observatory.common import daemons

from warwick.w1m.environment import(
    DisableParameterStatus,
    ParameterStatus)

SCRIPT_NAME = os.path.basename(sys.argv[0])
sys.excepthook = Pyro4.util.excepthook

FMT_YELLOW = u'\033[93m'
FMT_GREEN = u'\033[92m'
FMT_RED = u'\033[91m'
FMT_BOLD = u'\033[1m'
FMT_CLEAR = u'\033[0m'

UPS_STATUS = {
    1: FMT_BOLD + FMT_RED + 'UNKNOWN' + FMT_CLEAR,
    2: FMT_BOLD + FMT_GREEN + 'ONLINE' + FMT_CLEAR,
    3: FMT_BOLD + FMT_YELLOW + 'ON BATTERY' + FMT_CLEAR,
    4: FMT_BOLD + FMT_RED + 'SMART BOOST' + FMT_CLEAR,
    5: FMT_BOLD + FMT_RED + 'TIMED SLEEPING' + FMT_CLEAR,
    6: FMT_BOLD + FMT_RED + 'SOFTWARE BYPASS' + FMT_CLEAR,
    7: FMT_BOLD + FMT_RED + 'OFF' + FMT_CLEAR,
    8: FMT_BOLD + FMT_RED + 'REBOOTING' + FMT_CLEAR,
    9: FMT_BOLD + FMT_RED + 'SWITCHED BYPASS' + FMT_CLEAR,
    10: FMT_BOLD + FMT_RED + 'HARDWARE FAILURE BYPASS' + FMT_CLEAR,
    11: FMT_BOLD + FMT_RED + 'SLEEPING UNTIL POWER RETURNS' + FMT_CLEAR,
    12: FMT_BOLD + FMT_RED + 'ON SMART TRIM' + FMT_CLEAR,
}

DOOR_STATUS = {
    False: FMT_BOLD + 'OPEN' + FMT_CLEAR,
    True: FMT_BOLD + 'CLOSED' + FMT_CLEAR
}

SECSYS_STATUS = {
    False: FMT_BOLD + FMT_RED + 'TRIPPED' + FMT_CLEAR,
    True: FMT_BOLD + FMT_GREEN + 'SAFE' + FMT_CLEAR
}

STATUS_COLORS = {
    ParameterStatus.Unsafe: FMT_BOLD + FMT_RED,
    ParameterStatus.Safe: FMT_BOLD + FMT_GREEN,
    ParameterStatus.Disabled: FMT_BOLD
}

def print_status():
    """Prints the latest environment data in human-readable form"""
    status = None

    try:
        with daemons.onemetre_environment.connect() as environment:
            status = environment.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the environment daemon')
        return 1

    safe = False
    if status is None:
        print('No data available')
    else:
        safe = not any(status[sensor]['status'] == ParameterStatus.Unsafe for sensor in status)
        print('It is {}{}{} to observe'.format(
            FMT_GREEN + FMT_BOLD if safe else FMT_RED + FMT_BOLD,
            'SAFE' if safe else 'NOT SAFE', FMT_CLEAR))
        print()

        vaisala = status['vaisala']
        if vaisala['measurement_count'] > 0:
            print('Vaisala data from ' + format_date(vaisala))

            data = vaisala['data']
            wind_valid = data['wind_speed_valid']['status'] == ParameterStatus.Safe
            print('             Wind: ' + format_measurement(data['wind_speed'], ' km/h',
                                                             valid=wind_valid))
            print('      Median Wind: ' + format_measurement(data['median_wind_speed'], ' km/h'))

            pressure_valid = data['pressure_valid']['status'] == ParameterStatus.Safe
            print('         Pressure: ' + format_measurement(data['pressure'], ' hPa',
                                                             valid=pressure_valid))

            temp_valid = data['temperature_valid']['status'] == ParameterStatus.Safe
            print('    Outside Temp.: ' + format_measurement(data['temperature'], '\u00B0C',
                                                             valid=temp_valid))

            humidity_valid = data['relative_humidity_valid']['status'] == ParameterStatus.Safe
            print('     Outside Hum.: ' + format_measurement(data['relative_humidity'], ' %RH',
                                                             valid=humidity_valid))

            dewptd_valid = data['dew_point_delta_valid']['status'] == ParameterStatus.Safe
            print('  Temp. > Dew Pt.: ' + format_measurement(data['dew_point_delta'], '\u00B0C',
                                                             fmt='.2f', valid=dewptd_valid))

            acc_rain_valid = data['accumulated_rain_valid']['status'] == ParameterStatus.Safe
            print('Accumulated Rain.: ' + format_measurement(data['accumulated_rain'], ' mm',
                                                             fmt='.2f', valid=acc_rain_valid))
        else:
            print(FMT_RED + FMT_BOLD + 'No Vaisala data available' + FMT_CLEAR)
        print()

        roomalert = status['roomalert']
        if roomalert['measurement_count'] > 0:
            print('RoomAlert data from ' + format_date(roomalert))

            data = roomalert['data']
            print('   Internal Temp.: ' + format_measurement(data['internal_temp'], '\u00B0C'))
            print('    Internal Hum.: ' + format_measurement(data['internal_humidity'], ' %RH'))
            print('      Truss Temp.: ' + format_measurement(data['truss_temp'], '\u00B0C'))
            print('     Server Temp.: ' + format_measurement(data['roomalert_temp'], '\u00B0C'))
            print('      Server Hum.: ' + format_measurement(data['roomalert_humidity'], ' %RH'))
            print('       Side Hatch: ' + format_set(data['hatch_closed'], DOOR_STATUS))
            print('        Trap Door: ' + format_set(data['trap_closed'], DOOR_STATUS))
            print(' Tel. Sec. System: ' + format_set(data['security_system_safe'], SECSYS_STATUS))
        else:
            print(FMT_RED + FMT_BOLD + 'No Room Alert data available' + FMT_CLEAR)
        print()

        superwasp = status['superwasp']
        if superwasp['measurement_count'] > 0:
            print('SuperWASP data from ' + format_date(superwasp))

            data = superwasp['data']
            print('     Outside Hum.: ' + format_measurement(data['ext_humidity'], ' %RH'))
            print('        Sky Temp.: ' + format_measurement(data['sky_temp'], '\u00B0C'))
            print('  Temp. > Dew Pt.: ' + format_measurement(data['dew_point_delta'], '\u00B0C',
                                                             fmt='.2f'))
        else:
            print(FMT_YELLOW + FMT_BOLD + 'No SuperWASP data available' + FMT_CLEAR)
        print()

        tng = status['tng']
        if tng['measurement_count'] > 0:
            print('TNG data from ' + format_date(tng))

            data = tng['data']
            dust_valid = data['dust_valid']['latest'] == True
            print('       Dust Conc.: ' + format_measurement(data['dust'], ' ug/m\u00B3',
                                                             valid=dust_valid))
            seeing_valid = data['seeing_valid']['latest'] == True
            print('           Seeing: ' + format_measurement(data['seeing'], '"',
                                                             valid=seeing_valid))
        else:
            print(FMT_YELLOW + FMT_BOLD + 'No TNG data available' + FMT_CLEAR)
        print()

        power = status['power']
        if power['measurement_count'] > 0:
            print('UPS data from ' + format_date(power))
            data = power['data']
            print('         Main UPS: ' + format_ups(data, 'main_ups'))
            print('         Dome UPS: ' + format_ups(data, 'dome_ups'))
        else:
            print(FMT_RED + FMT_BOLD + 'No UPS data available' + FMT_CLEAR)
        print()

        netping = status['netping']
        if netping['measurement_count'] > 0:
            print('Network ping data from ' + format_date(netping))
            data = netping['data']
            print('           Google: ' + format_measurement(data['google'], ' ms'))
            print('         NGTSHead: ' + format_measurement(data['ngtshead'], ' ms'))
        else:
            print(FMT_RED + FMT_BOLD + 'No ping data available' + FMT_CLEAR)
        print()

        diskspace = status['diskspace']
        if diskspace['measurement_count'] > 0:
            print('Disk space from ' + format_date(diskspace))

            data = diskspace['data']
            print('   Data Partition: ' + format_diskspace(data['data_fs_available_bytes'],
                                                           data['data_fs_percent_available']))
        else:
            print(FMT_RED + FMT_BOLD + 'No disk space data available' + FMT_CLEAR)
        print()

    return safe

def print_json():
    """Prints the latest environment data in machine-readable form"""
    status = None
    try:
        with daemons.onemetre_environment.connect() as environment:
            status = environment.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the environment daemon')
        return 1

    print(json.dumps(status))

    return 0

def format_date(data):
    """Builds a formatted date string for the named data group"""
    start = datetime.datetime.strptime(data['measurement_start'], '%Y-%m-%dT%H:%M:%SZ')
    end = datetime.datetime.strptime(data['measurement_end'], '%Y-%m-%dT%H:%M:%SZ')

    ret = FMT_BOLD
    if data['measurement_status'] == ParameterStatus.Unsafe:
        ret += FMT_RED
    elif data['measurement_status'] == ParameterStatus.Disabled:
        ret += FMT_YELLOW

    ret += '{0} \u2014 {1}'.format(start.strftime('%H:%M:%S'), end.strftime('%H:%M:%S')) + FMT_CLEAR
    return ret

def format_value(value, limits, fmt='.1f'):
    """Builds a formatted string colored based on the specified limits"""
    color = FMT_BOLD
    if limits:
        color += FMT_RED if value < limits[0] or value > limits[1] else FMT_GREEN
    return color +  ('{0' + fmt +'}').format(value) + FMT_CLEAR

def format_measurement(data, suffix='', fmt='.1f', valid=True):
    """Builds a formatted string with a value range"""

    if not valid:
        return FMT_RED + FMT_BOLD + 'NO DATA' + FMT_CLEAR

    if fmt != '':
        fmt = ':' + fmt

    ret = ''

    limits = data['limits'] if 'limits' in data else None
    if 'min' in data:
        ret += format_value(data['min'], limits, fmt) + ' \u2264 '

    ret += format_value(data['latest'], limits, fmt)

    if 'max' in data:
        ret += ' \u2264 ' + format_value(data['max'], limits, fmt)

    ret += suffix

    if data['status'] == ParameterStatus.Disabled and limits:
        ret += FMT_YELLOW + FMT_BOLD + ' (DISABLED)' + FMT_CLEAR

    return ret

def format_set(data, values):
    """Builds a formatted string with specified values"""
    display_values = [values[value] for value in values if value in data['values']]

    ret = values[data['latest']] if data['latest'] in values else ''

    if len(data['values']) > 1:
        if ret:
            ret += ' '
        ret += '[' + ', '.join(display_values) + ']'

    if data['status'] == ParameterStatus.Disabled and 'valid_values' in data:
        ret += FMT_YELLOW + FMT_BOLD + ' (DISABLED)' + FMT_CLEAR

    return ret

def format_ups(data, prefix):
    """Builds a formatted string for a UPS status"""
    battery_data = data[prefix + '_battery_remaining']
    battery = format_value(battery_data['latest'], battery_data['limits'], fmt='') + '%'

    ret = format_set(data[prefix + '_status'], UPS_STATUS)
    ret += ' (' + battery + ' battery)'

    if False in data[prefix + '_battery_healthy']['values']:
        ret += FMT_BOLD + FMT_YELLOW + ' REPLACE BATTERY' + FMT_CLEAR

    return ret

def format_diskspace(raw, percent):
    """Builds a formatted string for the disk status"""
    bytes_safe = raw['latest'] >= raw['limits'][0] and raw['latest'] <= raw['limits'][1]
    bytes_color = FMT_GREEN if bytes_safe else FMT_RED
    bytes_str = FMT_BOLD + bytes_color + str(round(raw['latest'] / 2**30, 1)) + FMT_CLEAR

    percent_safe = percent['latest'] >= percent['limits'][0] \
        and percent['latest'] <= percent['limits'][1]
    percent_color = FMT_GREEN if percent_safe else FMT_RED
    percent_str = FMT_BOLD + percent_color + '{0:.0f}'.format(percent['latest']) + FMT_CLEAR

    return '{0} GiB ({1}%) available'.format(bytes_str, percent_str)

def override_parameter_limits(disable, args):
    """Disable or re-enable a watcher parameter"""
    arg_count = len(args)
    if arg_count == 1 or arg_count == 2:
        watcher = args[0]
        parameter = args[1] if arg_count == 2 else None
        try:
            with daemons.onemetre_environment.connect() as environment:
                ret = environment.override_parameter_limits(watcher, parameter, disable)
                if ret == DisableParameterStatus.Success:
                    return 0

                if ret == DisableParameterStatus.InvalidWatcher:
                    print('error: invalid id ' + watcher)
                elif ret == DisableParameterStatus.InvalidParameter:
                    print('error: invalid parameter ' + parameter)
                else:
                    print('error: unknown error code ' + str(ret))
                return 1
        except Pyro4.errors.CommunicationError:
            print('error: unable to communicate with the environment daemon')
            return 1

    command = 'override' if disable else 'restore'
    print('usage: {} {} <watcher> [<parameter>]'.format(SCRIPT_NAME, command))
    return 1

def list_watchers():
    """Print a list of watcher names (for use by bash completions)"""
    try:
        with daemons.onemetre_environment.connect() as environment:
            names = environment.list_watchers()
            print(' '.join(names))
            return 0
    except Pyro4.errors.CommunicationError:
        print('')
        return 1

def list_limited_parameters(args):
    """Print a list of watcher parameter names (for use by bash completions)"""
    if not args:
        print('')
        return 1

    try:
        with daemons.onemetre_environment.connect() as environment:
            names = environment.list_limited_parameters(args[0])
            print(' '.join(names))
            return 0
    except Pyro4.errors.CommunicationError:
        print('')
        return 1

def print_usage(name):
    """Prints the utility help"""
    print('Usage: {} <command>'.format(name))
    print()
    print('   status      print a human-readable summary of the aggregated environment status')
    print('   json        print a machine-readable summary of the aggregated environment status')
    print('   override    temporarily disable triggering on an environment parameter')
    print('   restore     re-enable triggering on an environment parameter')
    # list_watchers and list_limited_parameters are only useful for bash completion
    # so they are not listed here
    print()

    return 1

if __name__ == '__main__':
    if len(sys.argv) == 1:
        sys.exit(print_usage(SCRIPT_NAME))

    if sys.argv[1] == 'status':
        sys.exit(print_status())
    elif sys.argv[1] == 'json':
        sys.exit(print_json())
    elif sys.argv[1] == 'override':
        sys.exit(override_parameter_limits(True, sys.argv[2:]))
    elif sys.argv[1] == 'restore':
        sys.exit(override_parameter_limits(False, sys.argv[2:]))
    elif sys.argv[1] == 'list-watchers':
        sys.exit(list_watchers())
    elif sys.argv[1] == 'list-limited-parameters':
        sys.exit(list_limited_parameters(sys.argv[2:]))

    # Command not found
    sys.exit(print_usage(SCRIPT_NAME))
