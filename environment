#!/usr/bin/env python3
#
# This file is part of environmentd.
#
# environmentd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# environmentd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with environmentd.  If not, see <http://www.gnu.org/licenses/>.

"""Commandline client for communicating with environmentd"""

# pylint: disable=too-many-statements
# pylint: disable=too-many-branches
# pylint: disable=too-many-locals

import datetime
import json
import os
import sys
import Pyro4

PYRO_HOST = '192.168.0.102'
PYRO_PORT = 9002
PYRO_NAME = 'environment_daemon'
PYRO_COMM_TIMEOUT = 5

PYRO_URI = 'PYRO:' + PYRO_NAME + '@' + PYRO_HOST + ':' + str(PYRO_PORT)
SCRIPT_NAME = os.path.basename(sys.argv[0])
sys.excepthook = Pyro4.util.excepthook

FMT_YELLOW = u'\033[93m'
FMT_GREEN = u'\033[92m'
FMT_RED = u'\033[91m'
FMT_BOLD = u'\033[1m'
FMT_CLEAR = u'\033[0m'

UPS_STATUS = {
    1: FMT_BOLD + FMT_RED + 'UNKNOWN' + FMT_CLEAR,
    2: FMT_BOLD + FMT_GREEN + 'ONLINE' + FMT_CLEAR,
    3: FMT_BOLD + FMT_YELLOW + 'ON BATTERY' + FMT_CLEAR,
    4: FMT_BOLD + FMT_RED + 'SMART BOOST' + FMT_CLEAR,
    5: FMT_BOLD + FMT_RED + 'TIMED SLEEPING' + FMT_CLEAR,
    6: FMT_BOLD + FMT_RED + 'SOFTWARE BYPASS' + FMT_CLEAR,
    7: FMT_BOLD + FMT_RED + 'OFF' + FMT_CLEAR,
    8: FMT_BOLD + FMT_RED + 'REBOOTING' + FMT_CLEAR,
    9: FMT_BOLD + FMT_RED + 'SWITCHED BYPASS' + FMT_CLEAR,
    10: FMT_BOLD + FMT_RED + 'HARDWARE FAILURE BYPASS' + FMT_CLEAR,
    11: FMT_BOLD + FMT_RED + 'SLEEPING UNTIL POWER RETURNS' + FMT_CLEAR,
    12: FMT_BOLD + FMT_RED + 'ON SMART TRIM' + FMT_CLEAR,
}

def print_status():
    """Prints the latest environment data in human-readable form"""
    status = None

    try:
        with Pyro4.Proxy(PYRO_URI) as environment:
            status = environment.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the environment daemon')
        return 1

    if status is None:
        print('No data available')
    else:
        print('It is {}{}{} to observe'.format(
            FMT_GREEN + FMT_BOLD if status['can_observe'] else FMT_RED + FMT_BOLD,
            'SAFE' if status['can_observe'] else 'NOT SAFE', FMT_CLEAR))
        print()

        if status['vaisala_queue_len'] > 0:
            print('Vaisala data from ' + format_date(status, 'vaisala'))

            wind_valid = False not in status['vaisala_wind_speed_valid']
            print('             Wind: ' + format_range(status['vaisala_wind_speed'], ' km/h',
                                                       valid=wind_valid))
            print('      Median Wind: ' + format_single(status['vaisala_median_wind_speed'],
                                                        ' km/h'))

            pressure_valid = False not in status['vaisala_pressure_valid']
            print('         Pressure: ' + format_range(status['vaisala_pressure'], ' hPa',
                                                       valid=pressure_valid))

            temp_valid = False not in status['vaisala_temperature_valid']
            print('    Outside Temp.: ' + format_range(status['vaisala_temperature'], '\u00B0C',
                                                       valid=temp_valid))

            humidity_valid = False not in status['vaisala_relative_humidity_valid']
            print('     Outside Hum.: ' + format_range(status['vaisala_relative_humidity'],
                                                       ' %RH', valid=humidity_valid))

            accumulated_rain_valid = False not in status['vaisala_accumulated_rain_valid']
            print('Accumulated Rain.: ' + format_range(status['vaisala_accumulated_rain'], ' mm',
                                                       fmt='.2f', valid=accumulated_rain_valid))
            print()
        else:
            print(FMT_RED + FMT_BOLD + 'No Vaisala data available' + FMT_CLEAR)

        if status['roomalert_queue_len'] > 0:
            print('RoomAlert data from ' + format_date(status, 'roomalert'))
            print('   Internal Temp.: ' + format_range(status['roomalert_internal_temp'],
                                                       '\u00B0C'))
            print('    Internal Hum.: ' + format_range(status['roomalert_internal_humidity'],
                                                       ' %RH'))
            print('      Truss Temp.: ' + format_range(status['roomalert_truss_temp'],
                                                       '\u00B0C', color=False))
            print('     Server Temp.: ' + format_range(status['roomalert_roomalert_temp'],
                                                       '\u00B0C', color=False))
            print('      Server Hum.: ' + format_range(status['roomalert_roomalert_humidity'],
                                                       ' %RH', color=False))
            print('       Side Hatch: ' + format_open_closed(status['roomalert_hatch_closed']))
            print('        Trap Door: ' + format_open_closed(status['roomalert_trap_closed']))
        else:
            print(FMT_RED + FMT_BOLD + 'No Room Alert data available' + FMT_CLEAR)
        print()

        if status['superwasp_queue_len'] > 0:
            print('SuperWASP data from ' + format_date(status, 'superwasp'))
            #print('     Outside Hum.: ' + format_range(status['superwasp_ext_humidity'], ' %RH'))
            print('        Sky Temp.: ' + format_range(status['superwasp_sky_temp'], '\u00B0C'))
            #print('  Temp. > Dew Pt.: ' + format_range(status['superwasp_dew_point_delta'],
            #                                           '\u00B0C', fmt='.2f'))
        else:
            print(FMT_RED + FMT_BOLD + 'No SuperWASP data available' + FMT_CLEAR)
        print()

        if status['tng_queue_len'] > 0:
            print('TNG data from ' + format_date(status, 'tng'))
            print('       Dust Conc.: ' + format_range(status['tng_dust'], ' ug/m\u00B3'))
        else:
            print(FMT_RED + FMT_BOLD + 'No TNG data available' + FMT_CLEAR)
        print()

        if status['power_queue_len'] > 0:
            print('UPS data from ' + format_date(status, 'power'))
            print('         Main UPS: ' + format_ups(status, 'power_main_ups'))
            print('         Dome UPS: ' + format_ups(status, 'power_dome_ups'))
        else:
            print(FMT_RED + FMT_BOLD + 'No UPS data available' + FMT_CLEAR)
        print()

        if status['diskspace_queue_len'] > 0:
            # Convert from bytes to GiB
            data_bytes = status['diskspace_data_fs_available_bytes']
            data_gb = (round(data_bytes[0] / 2**30, 1), data_bytes[1])
            suffix = ' GiB ({}) available'.format(
                format_single(status['diskspace_data_fs_percent_available'], '%', fmt=''))
            print('Disk space from ' + format_date(status, 'diskspace'))
            print('   Data Partition: ' + format_single(data_gb, suffix))
        else:
            print(FMT_RED + FMT_BOLD + 'No disk space data available' + FMT_CLEAR)
        print()
    return status is None or not status['can_observe']

def print_json():
    """Prints the latest environment data in machine-readable form"""
    status = None
    try:
        with Pyro4.Proxy(PYRO_URI) as environment:
            status = environment.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the environment daemon')
        return 1

    print(json.dumps(status))

    return 0

def format_date(data, group):
    """Builds a formatted date string for the named data group"""
    start = datetime.datetime.strptime(data[group + '_measurement_start'], '%Y-%m-%dT%H:%M:%SZ')
    end = datetime.datetime.strptime(data[group + '_measurement_end'], '%Y-%m-%dT%H:%M:%SZ')
    data = (start.strftime('%H:%M:%S'), end.strftime('%H:%M:%S'), data[group + '_sufficient_data'])
    return format_range(data, ':', fmt='')

def format_range(data, suffix='', fmt='.1f', color=True, valid=True):
    """Builds a formatted string with a value range"""
    if fmt != '':
        fmt = ':' + fmt

    color_fmt = FMT_BOLD + ('' if not color else FMT_GREEN if data[2] else FMT_RED)
    min_value = color_fmt + ('{0' + fmt +'}').format(data[0]) + FMT_CLEAR
    max_value = color_fmt + ('{0' + fmt +'}').format(data[1]) + FMT_CLEAR

    # Show a single value if min and max are the same
    if data[0] == data[1]:
        ret = min_value
    else:
        ret = min_value + FMT_BOLD + ' \u2014 ' + FMT_CLEAR + max_value

    ret += suffix

    if not valid:
        ret += FMT_RED + FMT_BOLD + ' (INVALID)' + FMT_CLEAR

    return ret

def format_single(data, suffix='', fmt='.1f', color=True):
    """Builds a formatted string with a value"""
    return format_range((data[0], data[0], data[1]), suffix=suffix, fmt=fmt, color=color)

def format_open_closed(data):
    """Builds a formatted string with OPEN and/or CLOSED"""
    string = ""
    if False in data:
        string += "OPEN"
    if True in data:
        if len(string) > 0:
            string += ", "
        string += "CLOSED"
    return FMT_BOLD + string + FMT_CLEAR

def format_ups(data, prefix):
    """Builds a formatted string for a UPS status"""
    battery = format_range(data[prefix + '_battery_remaining'], '%', fmt='')
    ret = ''
    for status in data[prefix + '_status']:
        if len(ret) > 0:
            ret += ', '
        ret += UPS_STATUS[status]
    ret += ' (' + battery + ' battery)'

    if False in data[prefix + '_battery_healthy']:
        ret += FMT_BOLD + FMT_YELLOW + ' REPLACE BATTERY' + FMT_CLEAR

    return ret

def print_usage(name):
    """Prints the utility help"""
    print('Usage: {} <command>'.format(name))
    print()
    print('   status      print a human-readable summary of the aggregated environment status')
    print('   json        print a machine-readable summary of the aggregated environment status')
    print()

    return 1

if __name__ == '__main__':
    if len(sys.argv) == 1:
        sys.exit(print_usage(SCRIPT_NAME))

    Pyro4.config.COMMTIMEOUT = PYRO_COMM_TIMEOUT
    if sys.argv[1] == 'status':
        sys.exit(print_status())
    elif sys.argv[1] == 'json':
        sys.exit(print_json())

    # Command not found
    sys.exit(print_usage(SCRIPT_NAME))

