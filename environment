#!/usr/bin/env python3.6
#
# This file is part of environmentd.
#
# environmentd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# environmentd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with environmentd.  If not, see <http://www.gnu.org/licenses/>.

"""Commandline client for communicating with environmentd"""

# pylint: disable=too-many-statements
# pylint: disable=too-many-branches
# pylint: disable=too-many-locals
# pylint: disable=too-few-public-methods
# pylint: disable=bare-except

import datetime
import json
import os
import sys
import Pyro4
from warwick.observatory.common import daemons

DAEMONS = {
    'onemetre': daemons.onemetre_environment,
    'rasa': daemons.rasa_environment
}

SCRIPT_NAME = os.path.basename(sys.argv[0])
sys.excepthook = Pyro4.util.excepthook

FMT_YELLOW = u'\033[93m'
FMT_GREEN = u'\033[92m'
FMT_RED = u'\033[91m'
FMT_BOLD = u'\033[1m'
FMT_CLEAR = u'\033[0m'

UPS_STATUS = {
    1: FMT_BOLD + FMT_RED + 'UNKNOWN' + FMT_CLEAR,
    2: FMT_BOLD + FMT_GREEN + 'ONLINE' + FMT_CLEAR,
    3: FMT_BOLD + FMT_YELLOW + 'ON BATTERY' + FMT_CLEAR,
    4: FMT_BOLD + FMT_RED + 'SMART BOOST' + FMT_CLEAR,
    5: FMT_BOLD + FMT_RED + 'TIMED SLEEPING' + FMT_CLEAR,
    6: FMT_BOLD + FMT_RED + 'SOFTWARE BYPASS' + FMT_CLEAR,
    7: FMT_BOLD + FMT_RED + 'OFF' + FMT_CLEAR,
    8: FMT_BOLD + FMT_RED + 'REBOOTING' + FMT_CLEAR,
    9: FMT_BOLD + FMT_RED + 'SWITCHED BYPASS' + FMT_CLEAR,
    10: FMT_BOLD + FMT_RED + 'HARDWARE FAILURE BYPASS' + FMT_CLEAR,
    11: FMT_BOLD + FMT_RED + 'SLEEPING UNTIL POWER RETURNS' + FMT_CLEAR,
    12: FMT_BOLD + FMT_RED + 'ON SMART TRIM' + FMT_CLEAR,
}

DOOR_STATUS = {
    False: FMT_BOLD + 'OPEN' + FMT_CLEAR,
    True: FMT_BOLD + 'CLOSED' + FMT_CLEAR
}

SECSYS_STATUS = {
    False: FMT_BOLD + FMT_RED + 'TRIPPED' + FMT_CLEAR,
    True: FMT_BOLD + FMT_GREEN + 'SAFE' + FMT_CLEAR
}

def print_status(daemon):
    """Prints the latest environment data in human-readable form"""
    try:
        with daemon.connect() as environment:
            data = environment.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the environment daemon')
        return 1

    if data is None:
        print('No data available')
    else:
        print_vaisala_status('W1m Vaisala', data.get('vaisala'))
        print_vaisala_status('GOTO Vaisala', data.get('goto_vaisala'))
        print_roomalert_status(data.get('roomalert'))
        print_rasa_roomalert_status(data.get('goto_roomalert'))
        print_superwasp_status(data.get('superwasp'))
        print_tng_status(data.get('tng'))
        print_power_status(data.get('power'))
        print_network_status(data.get('netping'))
        print_diskspace_status(data.get('diskspace'))
        print_ephem_status(data.get('ephem'))
    return 0

def print_vaisala_status(name, data):
    """Prints data from one of the Vaisala units"""
    if data is None:
        return

    print(name + ' data from ' + format_date(data))
    print('             Wind: ' + format_measurement(data['wind_speed'], ' km/h'))
    print('      Median Wind: ' + format_measurement(data['median_wind_speed'], ' km/h'))
    print('         Pressure: ' + format_measurement(data['pressure'], ' hPa'))
    print('    Outside Temp.: ' + format_measurement(data['temperature'], '\u00B0C'))
    print('     Outside Hum.: ' + format_measurement(data['relative_humidity'], ' %RH'))
    print('  Temp. > Dew Pt.: ' + format_measurement(data['dew_point_delta'], '\u00B0C', fmt='.2f'))
    print('Accumulated Rain.: ' + format_measurement(data['accumulated_rain'], ' mm', fmt='.2f'))
    print()

def print_roomalert_status(data):
    """Prints data from the W1m Room Alert"""
    if data is None:
        return

    print('Room Alert data from ' + format_date(data))
    print('   Internal Temp.: ' + format_measurement(data['internal_temp'], '\u00B0C'))
    print('    Internal Hum.: ' + format_measurement(data['internal_humidity'], ' %RH'))
    print('      Truss Temp.: ' + format_measurement(data['truss_temp'], '\u00B0C'))
    print('     Server Temp.: ' + format_measurement(data['roomalert_temp'], '\u00B0C'))
    print('      Server Hum.: ' + format_measurement(data['roomalert_humidity'], ' %RH'))
    print('       Side Hatch: ' + format_set(data['hatch_closed'], DOOR_STATUS))
    print('        Trap Door: ' + format_set(data['trap_closed'], DOOR_STATUS))
    print(' Tel. Sec. System: ' + format_set(data['security_system_safe'], SECSYS_STATUS))
    print()

def print_rasa_roomalert_status(data):
    """Prints RASA data from the GOTO Room Alert"""
    if data is None:
        return

    print('Room Alert data from ' + format_date(data))
    print('   Internal Temp.: ' + format_measurement(data['dome2_internal_temp'], '\u00B0C'))
    print('    Internal Hum.: ' + format_measurement(data['dome2_internal_humidity'], ' %RH'))
    print()

def print_superwasp_status(data):
    """Prints data from the SuperWASP weather log"""
    if data is None:
        return

    print('SuperWASP data from ' + format_date(data))
    print('     Outside Hum.: ' + format_measurement(data['ext_humidity'], ' %RH'))
    print('        Sky Temp.: ' + format_measurement(data['sky_temp'], '\u00B0C'))
    print('  Temp. > Dew Pt.: ' + format_measurement(data['dew_point_delta'], '\u00B0C', fmt='.2f'))
    print()

def print_tng_status(data):
    """Prints data from the TNG weather log"""
    if data is None:
        return

    print('TNG data from ' + format_date(data))
    print('       Dust Conc.: ' + format_measurement(data['dust'], ' ug/m\u00B3'))
    print('           Seeing: ' + format_measurement(data['seeing'], '"'))
    print()

def print_power_status(data):
    """Prints data from the W1m UPSes"""
    if data is None:
        return

    print('UPS data from ' + format_date(data))
    if 'main_ups_battery_remaining' in data:
        print('         Main UPS: ' + format_ups(data, 'main_ups'))
    if 'dome_ups_battery_remaining' in data:
        print('         Dome UPS: ' + format_ups(data, 'dome_ups'))
    if 'ups_battery_remaining' in data:
        print('              UPS: ' + format_ups(data, 'ups'))
    print()

def print_network_status(data):
    """Prints data from the network ping monitor"""
    if data is None:
        return

    print('Network ping data from ' + format_date(data))
    print('           Google: ' + format_measurement(data['google'], ' ms'))
    print('         NGTSHead: ' + format_measurement(data['ngtshead'], ' ms'))
    print()

def print_diskspace_status(data):
    """Prints data from the W1m TCS disk space monitor"""
    if data is None:
        return

    print('Disk space from ' + format_date(data))
    print('   Data Partition: ' + format_diskspace(data['data_fs_available_bytes'],
                                                   data['data_fs_percent_available']))
    print()

def print_ephem_status(data):
    """Prints sun/moon status"""
    if data is None:
        return

    print('Ephemeris from ' + format_date(data))
    print('     Sun Altitude: ' + format_measurement(data['sun_alt'], '\u00B0'))
    print('    Moon Altitude: ' + format_measurement(data['moon_alt'], '\u00B0'))
    print('       Moon Phase: ' + format_measurement(data['moon_phase'], '%'))

def print_json(daemon):
    """Prints the latest environment data in machine-readable form"""
    status = None
    try:
        with daemon.connect() as environment:
            status = environment.status()
    except Pyro4.errors.CommunicationError:
        print('error: unable to communicate with the environment daemon')
        return 1

    print(json.dumps(status))

    return 0

def format_date(data):
    """Builds a formatted date string for the named data group"""
    start = None
    end = None
    current = False
    for param in data:
        try:
            param_start = datetime.datetime.strptime(data[param]['date_start'],
                                                     '%Y-%m-%dT%H:%M:%SZ')
            param_end = datetime.datetime.strptime(data[param]['date_end'], '%Y-%m-%dT%H:%M:%SZ')
            start = param_start if not start else min(start, param_start)
            end = param_end if not end else min(end, param_end)
            current = current or data[param]['current']
        except:
            pass

    ret = FMT_BOLD
    if start and end:
        ret += start.strftime('%H:%M:%S') + ' \u2014 '
        if not current:
            ret += FMT_RED
        ret += end.strftime('%H:%M:%S') + FMT_CLEAR
        ret += FMT_BOLD + ':' + FMT_CLEAR
    else:
        ret += FMT_RED + 'NO DATA' + FMT_CLEAR
    return ret

def format_value(value, limits, warn_limits, fmt='.1f'):
    """Builds a formatted string colored based on the specified limits"""
    color = FMT_BOLD
    if limits or warn_limits:
        if limits and (value < limits[0] or value > limits[1]):
            color += FMT_RED
        elif warn_limits and (value < warn_limits[0] or value > warn_limits[1]):
            color += FMT_YELLOW
        else:
            color += FMT_GREEN
    return color +  ('{0' + fmt +'}').format(value) + FMT_CLEAR

def format_measurement(data, suffix='', fmt='.1f'):
    """Builds a formatted string with a value range"""
    if fmt != '':
        fmt = ':' + fmt

    ret = ''
    limits = data['limits'] if 'limits' in data else None
    warn_limits = data['warn_limits'] if 'warn_limits' in data else None
    if 'min' in data:
        ret += format_value(data['min'], limits, warn_limits, fmt) + ' \u2264 '

    if data['current']:
        ret += format_value(data['latest'], limits, warn_limits, fmt)
    else:
        ret += FMT_RED + FMT_BOLD + 'NO DATA' + FMT_CLEAR

    if 'max' in data:
        ret += ' \u2264 ' + format_value(data['max'], limits, warn_limits, fmt)

    if data['current'] or 'max' in data:
        ret += suffix

    if data['unsafe']:
        ret += FMT_RED + FMT_BOLD + ' (UNSAFE)' + FMT_CLEAR
    elif data['warning']:
        ret += FMT_RED + FMT_YELLOW + ' (WARNING)' + FMT_CLEAR

    return ret

def format_set(data, values):
    """Builds a formatted string with specified values"""
    if data['current']:
        ret = values[data['latest']] if data['latest'] in values else ''
    else:
        ret = FMT_RED + FMT_BOLD + 'NO DATA' + FMT_CLEAR

    if 'values' in data and (len(data['values']) > 1 or not data['current']):
        if ret:
            ret += ' '
        display_values = [values[value] for value in values if value in data['values']]
        ret += '[' + ', '.join(display_values) + ']'

    if data['unsafe']:
        ret += FMT_RED + FMT_BOLD + ' (UNSAFE)' + FMT_CLEAR
    elif data['warning']:
        ret += FMT_RED + FMT_YELLOW + ' (WARNING)' + FMT_CLEAR

    return ret

def format_ups(data, prefix):
    """Builds a formatted string for a UPS status"""
    battery_data = data[prefix + '_battery_remaining']

    if battery_data['current']:
        battery = format_value(battery_data['latest'], battery_data['limits'],
                               battery_data['warn_limits'], fmt='') + '%'
    else:
        battery = FMT_RED + FMT_BOLD + 'NO DATA' + FMT_CLEAR

    ret = format_set(data[prefix + '_status'], UPS_STATUS)
    ret += ' (' + battery + ' battery)'

    battery_healthy = data[prefix + '_battery_healthy']
    if battery_healthy['current'] and False in battery_healthy['values']:
        ret += FMT_BOLD + FMT_YELLOW + ' REPLACE BATTERY' + FMT_CLEAR

    return ret

def format_diskspace(raw, percent):
    """Builds a formatted string for the disk status"""
    if raw['current']:
        bytes_safe = raw['latest'] >= raw['limits'][0] and raw['latest'] <= raw['limits'][1]
        bytes_color = FMT_GREEN if bytes_safe else FMT_RED
        bytes_str = FMT_BOLD + bytes_color + str(round(raw['latest'] / 2**30, 1)) + FMT_CLEAR

        return '{0} GiB available'.format(bytes_str)

    return FMT_RED + FMT_BOLD + 'NO DATA' + FMT_CLEAR

def print_usage(name):
    """Prints the utility help"""
    print('Usage: {} [onemetre|rasa] <command>'.format(name))
    print()
    print('   status      print a human-readable summary of the aggregated environment status')
    print('   json        print a machine-readable summary of the aggregated environment status')
    print()

    return 1

if __name__ == '__main__':
    if len(sys.argv) < 3 or sys.argv[1] not in DAEMONS:
        sys.exit(print_usage(SCRIPT_NAME))

    if sys.argv[2] == 'status':
        sys.exit(print_status(DAEMONS[sys.argv[1]]))
    elif sys.argv[2] == 'json':
        sys.exit(print_json(DAEMONS[sys.argv[1]]))

    # Command not found
    sys.exit(print_usage(SCRIPT_NAME))
